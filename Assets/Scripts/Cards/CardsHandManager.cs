// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System;


namespace Cards
{
	public class CardsHandManager : MonoBehaviour
	{

		public enum modes {_DeckBuild = 1, _GameOn = 2};

		public static CardsHandManager instance;
		public static int handSize = 5;
		public Transform deck;

		public CardTransform selectedCard;

		public CardsList cardsInDeck;

		public CardsList cardsInDiscard;

		public CardsList cardsInHand;

		private float distanceFromCenter =10f;
		private float distanceFromOtherCard;

		//this variable is used to store in what mode the game is on, so the card activations will have different effects
		public modes mode;

		public CardPrefabInstatiator instantiator;

		//this position is used to store the cards that won't be used
		public Vector3 cardsLimbo = new Vector3(9999,9999,9999);

		public Vector3 managerPosition;
		public Vector3 managerRotation;


		void Awake ()
		{
			if (instance == null) {
				instance = this;
				instance.cardsInDeck = new CardsList ();
				instance.cardsInHand = new CardsList ();
				instantiator = new CardPrefabInstatiator ();
				instance.mode = modes._DeckBuild;
			} else {
				Destroy (this.gameObject);
			}

			DontDestroyOnLoad (this.gameObject);

		}

		public void GameStarted (){

			transform.SetParent (Camera.allCameras [0].transform);

			transform.localPosition = instance.managerPosition;
			transform.localRotation = Quaternion.Euler (instance.managerRotation);

			Debug.Log ("Position is " + transform.position);
			Debug.Log ("Rotation is " + transform.rotation);

			if (instance.mode == modes._GameOn) {
				Debug.Log ("instanti");
				CreateDeck();
				updateHand();
				updateCardsPosition ();
				
			} else {
				
			}

		}


		public static void changeModeToDeckBuild(){
			instance.mode = modes._DeckBuild;
		}

		public static void changeModeToGameOn(){
			Debug.Log ("mode changed");
			instance.mode = modes._GameOn;
		}

		public static CardsHandManager getInstance(){
			return instance;
		}

		private void instantiateDeck(){
			Card next = cardsInDeck.getNextCard ();
			Card first = cardsInDeck.first.card;
			bool firstTime = true;
			while((next != null && !next.Equals(first)) || firstTime){
				firstTime = false;

//				Instantiate(next.prefab, new Vector3(9999,9999,9999), Quaternion.identity);






//				next = cardsInDeck.next();
			}
		}

		public void updateCardsPosition(){
			int initialAngle = -15;
			float range = 7.5f*handSize;
			float increment = range/handSize;

			int cardCount = 0;

			Card first = instance.cardsInHand.first.card;
			bool firstTime = true;
			Card next = instance.cardsInHand.getNextCard();

			while(!first.Equals(next) || firstTime) {
				firstTime = false;

				float angle = initialAngle + increment*cardCount;
				Debug.Log (string.Format("The angle is {0}, and the increment is {1}, the cardCount is {2}", angle, increment, cardCount));

				Vector3 finalPosition = transform.position;

				finalPosition.x += distanceFromCenter*Mathf.Sin(Mathf.Deg2Rad*angle);
				finalPosition.y += 0.2f*cardCount;
				finalPosition.z += distanceFromCenter*Mathf.Cos(Mathf.Deg2Rad*angle);
				Debug.Log (finalPosition);
		
				next.updateTransform(finalPosition, Quaternion.Euler(90,  angle, 0));
				
				next = instance.cardsInHand.getNextCard();
				cardCount++;
			}
//0.8, -10.4, 12
		}

		public void updateHand(){
			Debug.Log ("Child Count: " + instance.transform.childCount);
			Debug.Log ("Hand Size: " + handSize);
			if (instance.transform.childCount < handSize) {
				for(int a = handSize - instance.transform.childCount; a != 0; a--){
					if(instance.cardsInDeck.Count == 0) ShuffleDeck();
					Card pop = instance.cardsInDeck.popFirstCard();
					pop.transform.SetParent(this.transform);
					instance.cardsInHand.addCard(pop);

				}
			}

		}

		public void ShuffleDeck(){
			
		}

		public static void CreateDeck(){
			instance._CreateDeck ();
		}

		private void _CreateDeck(){
			Debug.Log (instantiator.cardsToInstantiate.Count);
//			GameObject deck = GameObject.FindGameObjectWithTag ("");
			foreach (GameObject t in instantiator.cardsToInstantiate) {
				GameObject card = (GameObject) Instantiate(t, cardsLimbo, Quaternion.identity);
				card.transform.localScale= new Vector3 (0.25f, 0.35f, 0.35f);
				instance.cardsInDeck.addCard((Card) card.GetComponent<Card>());
			}
		}

	}
}

