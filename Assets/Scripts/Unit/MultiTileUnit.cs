//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

using TBTK;
namespace AssemblyCSharp
{
		public class MultiTileUnit: Unit
		{
			public static List<MultiTileUnit> unitList;
			private static Object lockDeath = new Object();
			private static bool dead;



			void Awake(){
				unitList = null;
				thisT=transform;
				dead = false;
				thisObj=gameObject;
				for(int i=0; i<shootPointList.Count; i++){
					if(shootPointList[i]==null){
						shootPointList.RemoveAt(i);
						i-=1;
					}
				}

			
				if(shootPointList.Count==0) shootPointList.Add(thisT);
			
				if(turretObject==null) turretObject=thisT;
			}

			void Start(){
				lock(lockDeath){
					if(unitList == null){
						GameObject[] objects = GameObject.FindGameObjectsWithTag(thisObj.tag);
						unitList = new List<MultiTileUnit>(); 
						foreach (GameObject ob in objects){
						MultiTileUnit mtu = ob.GetComponent<MultiTileUnit>();
							Debug.Log(mtu);
							unitList.Add(mtu);	
						}
					}
				}
			}
			
			public override void ApplyDamage(float dmg, bool critical=false, bool showOverlay = true){


				foreach (MultiTileUnit t in unitList){
					Debug.Log("MultiTile: " + t);
					t.baseApplyDamage(dmg, critical, showOverlay);
				}
			}

			public void baseApplyDamage(float dmg, bool critical, bool showOverlay = true){

				base.ApplyDamage(dmg, critical, showOverlay);
			}

			protected override IEnumerator Dead(){
				lock(lockDeath){
					if(!dead){
						if(destroyEffectObj!=null) Instantiate(destroyEffectObj, GetTargetT().position, Quaternion.identity);
						
						float delay=0;
						if(unitAudio!=null) delay=unitAudio.Destroy();
						if(unitAnim!=null) delay=Mathf.Max(delay, unitAnim.Destroy());
						dead = true;

						yield return new WaitForSeconds(delay);
					}
				}
				base.OnUnitDestroyed(this);

				Destroy(thisObj);
			}

		void OnDestroy(){
			Debug.Log("being destroyed");
		}
	}



}

